{"version":3,"file":"js/background.js","mappings":";;UAAA;UACA;;;;;WCDA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;ACNA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS,0CAA0C;AACnD,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gCAAgC;AACnE,MAAM;AACN,mCAAmC,iCAAiC;AACpE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,0CAA0C,iCAAiC;AAC3E,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA,uCAAuC,uCAAuC;AAC9E;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA,SAAS;AACT,sCAAsC,aAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA,yCAAyC,YAAY;AACrD;AACA;;AAEA,E","sources":["webpack:///webpack/bootstrap","webpack:///webpack/runtime/make namespace object","webpack:///./src/js/background.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const openai_url = 'https://api.openai.com/v1/chat/completions';\n\nlet defaultOptions = {\n    apiKey: \"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\",\n    prePrompt: \"I want you to act as a productivity assistant. \" +\n    \"I will provide you with a piece of content and you need to determine whether that piece of content \" +\n    \"will be helpful towards achieving my intention. My intention is: '[intention]'. You must answer with\" +\n    \"true or false to the statement, 'this content is helpful towards achieving the intention' and give your reasoning also.\" +\n    \"I want you to be lenient. If the page is likely to be degree away from a page that is helpful to the intention. \" +\n    \"Then it should be deemed to be helpful. Any content related\" +\n    \" to the acceptance of cookies should be ok too. Your response should be in json format with keys, reasoning and \" +\n    \"decision. Where decision is true or false. \"\n}\nbrowser.storage.sync.set(defaultOptions)\n\nfunction createSystemPrompt(prompt, intention) {\n    return prompt.replace(/\\[intention\\]/gi, intention);\n}\n\nfunction ask (systemPrompt, content, apiKey) {\n\n    const messages = [\n        {\"role\": \"system\", \"content\": systemPrompt},\n        {\"role\": \"user\", \"content\": content}\n    ];\n\n    return fetch(openai_url, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${apiKey}`,\n        },\n        body: JSON.stringify({\n            \"model\": \"gpt-3.5-turbo\",\n            'messages': messages,\n        })\n    })\n    .then(response => {\n        if (response.status === 401) {\n            throw Error(\"Check your API key is present in the preferences page for this extension\")\n        } else {\n            return response.json()\n        }\n    })\n    .then(data => data.choices[0].message.content)\n}\n\nasync function getIntention() {\n    return browser.storage.local.get(\"intention\")\n    .then(data => {\n        if (data.intention) {\n            return data.intention;\n        } else {\n            throw Error(\"No intention found\");\n        }\n    });\n}\n\nasync function getApiKey() {\n    return browser.storage.sync.get(\"apiKey\")\n    .then(data => {\n        if (data.apiKey) {\n            return data.apiKey;\n        } else {\n            throw Error(\"No API Key found\");\n        }\n    })\n}\n\nasync function getSystemPrompt(intention){\n    return browser.storage.sync.get(\"prePrompt\")\n    .then(data => {\n        if (data.prePrompt) {\n            return data.prePrompt;\n        } else {\n            throw Error(\"No Pre-Prompt found\");\n        }\n    })\n    .then(prompt => createSystemPrompt(prompt, intention));\n}\n\nasync function main(content) {\n    try {\n        const intention = await getIntention();\n        const systemPrompt = await getSystemPrompt(intention);\n        const apiKey = await getApiKey();\n        return ask(systemPrompt, content, apiKey);\n    } catch (e) {\n        console.log(e.message);\n        throw e;\n    }\n}\n\nwindow.current_reply = \"\";\n\nbrowser.storage.local.get(\"intention\")\n.then(data => {\n    if (!data.intention) {\n        updateIntention(\"I want to carry out web development on my firefox extension\");\n    }\n})\nfunction updateIntention(intention) {\n    browser.storage.local.set({ intention : intention })\n    .then(() => {\n        browser.storage.local.get(\"intentionHistory\")\n        .then(data => {\n            addToIntentionHistoryList(data.intentionHistory, intention);\n        })\n    })\n}\n\nfunction addToIntentionHistoryList(intentionList, intention) {\n    var intentionObj = {\n        words: intention,\n        favorite: false\n    };\n    if (intentionList) {\n        intentionList.push(intentionObj)\n        browser.storage.local.set({intentionHistory: intentionList})\n    } else {\n        browser.storage.local.set({intentionHistory: [intentionObj]})\n    }\n}\n\nfunction addRemoveIntentionFromFavoritesMap(intention) {\n    browser.storage.local.get(\"intentionFavorites\")\n    .then(data => {\n        var favoritesMap;\n        if (data.intentionFavorites) {\n            favoritesMap = data.intentionFavorites;\n            if (favoritesMap.has(intention)) {\n                favoritesMap.delete(intention)\n            } else {\n                favoritesMap.set(intention, true);\n            }\n        } else {\n            favoritesMap = new Map();\n            favoritesMap.set(intention, true);\n        }\n        return browser.storage.local.set({intentionFavorites: favoritesMap});\n    })\n}\n\nfunction toggleShowFavoriteInHistoryList(intention) {\n    browser.storage.local.get(\"intentionHistory\")\n    .then(data => {\n        if (data.intentionHistory) {\n            var intentionHistoryList = data.intentionHistory;\n            for (i = 0; i < intentionHistoryList.length; i++) {\n                if (intentionHistoryList[i].words === intention) {\n                    intentionHistoryList[i].favorite = !intentionHistoryList[i].favorite\n                }\n            }\n            browser.storage.local.set({intentionHistory: intentionHistoryList})\n        }\n    })\n}\n\nbrowser.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    if (message.intention) {\n        console.log(message.intention)\n        updateIntention(message.intention)\n    }\n    if (message.content) {\n        main(message.content)\n        .then(response => JSON.parse(response))\n        .then(reply => {\n            sendResponse({reply: reply});\n            window.current_reply = reply;\n        })\n        .catch(error => sendResponse({error: error}));\n        return true;\n    }\n    if (message.favorite) {\n        addRemoveIntentionFromFavoritesMap(message.favorite);\n        toggleShowFavoriteInHistoryList(message.favorite);\n    }\n});\n\n// // /*\n// // Update content when a new tab becomes active.\n// // */\n// browser.tabs.onActivated.addListener(sendParseMessage);\n\n/*\nUpdate content when a new page is loaded into a tab.\n*/\nbrowser.tabs.onUpdated.addListener(sendParseMessage);\n\n\nfunction sendParseMessage(tabId, changeInfo, tab) {\n    if (changeInfo && changeInfo.status === 'complete') {\n        browser.tabs.sendMessage(tabId, {parse: true});\n    }\n}\n\n  "],"names":[],"sourceRoot":""}